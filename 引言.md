在过去的五年里，Web开发人员的可用工具实现了跨越式地增长。当技术专家不断推动极限，使Web应用无处不在时，我们也不得不升级我们的工具、创建框架以保证构建更好的应用。我们希望能够使用新的工具，方便我们写出更加整洁、可维护的代码，使部署到世界各地的用户时拥有高效的可扩展性。

这就让我们谈论到Tornado，一个编写易创建、扩展和部署的强力Web应用的梦幻选择。我们三个都因为Tornado的速度、简单和可扩展性而深深地爱上了它，在一些个人项目中尝试之后，我们将其运用到日常工作中。我们已经看到，Tornado在很多大型或小型的项目中提升了开发者的速度（和乐趣！），同时，其鲁棒性和轻量级也给开发者一次又一次留下了深刻的印象。

本书的目的是对Tornado Web服务器进行一个概述，通过框架基础、一些示例应用和真实世界使用的最佳实践来引导读者。我们将使用示例来详细讲解Tornado如何工作，你可以用它做什么，以及在构建自己第一个应用时要避免什么。

在本书中，我们假定你对Python已经有了粗略的了解，知道Web服务如何运作，对数据库有一定的熟悉。有一些不错的书籍可以为你深入了解这些提供参考（比如Learning Python，Restful Web Service和MongoDB: The Definitive Guide）。

你可以在[Github](https://github.com/Introduction-to-Tornado)上获得本书中示例的代码。如果你有关于这些示例或其他方面的任何思想，欢迎在那里告诉我们。

所以，事不宜迟，让我们开始深入了解吧！

### Tornado是什么？

Tornado是使用Python编写的一个强大的、可扩展的Web服务器。它在处理严峻的网络流量时表现得足够强健，但却在创建和编写时有着足够的轻量级，并能够被用在大量的应用和工具中。

我们现在所知道的Tornado是基于Bret Taylor和其他人员为FriendFeed所开发的网络服务框架，当FriendFeed被Facebook收购后得以开源。不同于那些最多只能达到10,000个并发连接的传统网络服务器，Tornado在设计之初就考虑到了性能因素，旨在解决C10K问题，这样的设计使得其成为一个拥有非常高性能的框架。此外，它还拥有处理安全性、用户验证、社交网络以及与外部服务（如数据库和网站API）进行异步交互的工具。

### 延伸阅读：C10K问题

基于线程的服务器，如Apache，为了传入的连接，维护了一个操作系统的线程池。Apache会为每个HTTP连接分配线程池中的一个线程，如果所有的线程都处于被占用的状态并且尚有内存可用时，则生成一个新的线程。尽管不同的操作系统会有不同的设置，大多数Linux发布版中都是默认线程堆大小为8MB。Apache的架构在大负载下变得不可预测，为每个打开的连接维护一个大的线程池等待数据极易迅速耗光服务器的内存资源。

大多数社交网络应用都会展示实时更新来提醒新消息、状态变化以及用户通知，这就要求客户端需要保持一个打开的连接来等待服务器端的任何响应。这些长连接或推送请求使得Apache的最大线程池迅速饱和。一旦线程池的资源耗尽，服务器将不能再响应新的请求。

异步服务器在这一场景中的应用相对较新，但他们正是被设计用来减轻基于线程的服务器的限制的。当负载增加时，诸如Node.js，lighttpd和Tornodo这样的服务器使用协作的多任务的方式进行优雅的扩展。也就是说，如果当前请求正在等待来自其他资源的数据（比如数据库查询或HTTP请求）时，一个异步服务器可以明确地控制以挂起请求。异步服务器用来恢复暂停的操作的一个常见模式是当合适的数据准备好时调用回调函数。我们将会在第五章讲解回调函数模式以及一系列Tornado异步功能的应用。

自从2009年9月10日发布以来，TornadoTornado已经获得了很多社区的支持，并且在一系列不同的场合得到应用。除FriendFeed和Facebook外，还有很多公司在生产上转向Tornado，包括Quora、Turntable.fm、Bit.ly、Hipmunk以及MyYearbook等。

总之，如果你在寻找你那庞大的CMS或一体化开发框架的替代品，Tornado可能并不是一个好的选择。Tornado并不需要你拥有庞大的模型建立特殊的方式，或以某种确定的形式处理表单，或其他类似的事情。它所做的是让你能够快速简单地编写高速的Web应用。如果你想编写一个可扩展的社交应用、实时分析引擎，或RESTful API，那么简单而强大的Python，以及Tornado（和这本书）正是为你准备的！

### Tornado入门

在大部分Unix系统中安装Tornado非常容易，你即可以从PyPI获取（并使用easy_install或pip安装），也可以从Github上下载源码编译安装，如下所示：

```shell
$ curl -L -O https://github.com/facebook/tornado/archive/v3.1.0.tar.gz
$ tar xvzf v3.1.0.tar.gz
$ cd tornado-3.1.0
$ python setup.py build
$ sudo python setup.py install
```

Tornado官方并不支持Windows，但你可以通过ActivePython的PyPM包管理器进行安装，类似如下所示：

```shell
C:\> pypm install tornado
```

一旦Tornado在你的机器上安装好，你就可以很好的开始了！压缩包中包含很多demo，比如建立博客、整合Facebook、运行聊天服务等的示例代码。我们稍后会在本书中通过一些示例应用逐步讲解，不过你也应该看看这些官方demo。

### 社区和支持

对于问题、示例和一般的指南，Tornado官方文档是个不错的选择。在[tornadoweb.org](http://tornadoweb.org/)上有大量的例子和功能缺陷，更多细节和变更可以在[Tornado在Github上的版本库](http://github.com/facebook/tornado)中看到。而对于更具体的问题，可以到[Tornado的Google Group](http://groups.google.com/group/python-tornado)中咨询，那里有很多活跃的日常使用Tornado的开发者。

### 简单的Web服务

既然我们已经知道了Tornado是什么了，现在让我们看看它能做什么吧。我们首先从使用Tornado编写一个简单的Web应用开始。

### Hello Tornado

Tornado是一个编写对HTTP请求响应的框架。作为程序员，你的工作是编写响应特定条件HTTP请求的响应的handler。下面是一个全功能的Tornado应用的基础示例：

```python
import tornado.httpserver
import tornado.ioloop
import tornado.options
import tornado.web

from tornado.options import define, options
define("port", default=8000, help="run on the given port", type=int)

class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        greeting = self.get_argument('greeting', 'Hello')
        self.write(greeting + ', friendly user!')

if __name__ == "__main__":
    tornado.options.parse_command_line()
    app = tornado.web.Application(handlers=[(r"/", IndexHandler)])
    http_server = tornado.httpserver.HTTPServer(app)
    http_server.listen(options.port)
    tornado.ioloop.IOLoop.instance().start()
```

编写一个Tornado应用中最多的工作是定义类继承`Tornado`的**RequestHandler**类。在这个例子中，我们创建了一个简单的应用，在给定的端口监听请求，并在根目录（"/"）响应请求。

你可以在命令行里尝试运行这个程序以测试输出：

```shell
$ python hello.py --port=8000
```

现在你可以在浏览器中打开[http://localhost:8000](http://localhost:8000)，或者打开另一个终端窗口使用`curl`测试我们的应用：

```shell
$ curl http://localhost:8000/
Hello, friendly user!
$ curl http://localhost:8000/?greeting=Salutations
Salutations, friendly user!
```

现在让我们把这个例子分成小块，逐步来分析他们：

```python
import tornado.httpserver
import tornado.ioloop
import tornado.options
import tornado.web
```

在程序的最顶部，我们导入了一些Tornado模块。虽然Tornado还有另外一些有用的模块，但在这个例子中我们必须至少包含这四个模块。

```python
from tornado.options import define, options
define("port", default=8000, help="run on the given port", type=int)
```

Tornado包括了一个有用的模块（**tornado.options**）来从命令行中读取设置。我们在这里使用这个模块指定我们的应用监听HTTP请求的端口。它的工作流程如下：如果一个与**define**语句中同名的设置在命令行中被给出，那么它将成为全局**options**的一个属性。如果用户运行程序时使用了**--help**选项，程序将打印出所有你定义的选项以及你在**define**函数的**help**参数中指定的文本。如果用户没有为这个选项指定值，则使用**default**的值进行代替。`Tornado`使用**type**参数进行基本的参数类型验证，当不合适的类型被给出时抛出一个异常。因此，我们允许一个整数的**port**参数作为**options.port**来访问程序。如果用户没有指定值，则默认为8000。

```python
class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        greeting = self.get_argument('greeting', 'Hello')
        self.write(greeting + ', friendly user!')
```

这是Tornado的请求处理函数类。当处理一个请求时，Tornado将这个类实例化，并调用与HTTP请求方法所对应的方法。在这个例子中，我们只定义了一个**get**方法，也就是说这个处理函数将对HTTP的**GET**请求作出响应。我们稍后将看到实现不止一个HTTP方法的处理函数。

```python
greeting = self.get_argument('greeting', 'Hello')
```

Tornado的**RequestHandler**类有一系列有用的内建方法，包括**get_argument**，我们在这里从一个查询字符串中取得参数**greeting**的值。（如果这个参数没有出现在查询字符串中，Tornado将使用**get_argument**的第二个参数作为默认值。）

```python
self.write(greeting + ', friendly user!')
```

RequestHandler的另一个有用的方法是**write**，它以一个字符串作为函数的参数，并将其写入到HTTP响应中。在这里，我们使用请求中**greeting**参数提供的值插入到**greeting**中，并写回到响应中。

```python
if __name__ == "__main__":
    tornado.options.parse_command_line()
    app = tornado.web.Application(handlers=[(r"/", IndexHandler)])
```

这是真正使得Tornado运转起来的语句。首先，我们使用Tornado的**options**模块来解析命令行。然后我们创建了一个Tornado的**Application**类的实例。传递给**Application**类**__init__**方法的最重要的参数是**handlers**。它告诉Tornado应该用哪个类来响应请求。马上我们讲解更多相关知识。

```python
http_server = tornado.httpserver.HTTPServer(app)
http_server.listen(options.port)
tornado.ioloop.IOLoop.instance().start()
```

从这里开始的代码将会被反复使用：一旦**Application**对象被创建，我们可以将其传递给Tornado的**HTTPServer**对象，然后使用我们在命令行指定的端口进行监听（通过**options**对象取出。）最后，在程序准备好接收HTTP请求后，我们创建一个Tornado的**IOLoop**的实例。

### 参数handlers

让我们再看一眼hello.py示例中的这一行：

```python
app = tornado.web.Application(handlers=[(r"/", IndexHandler)])
```

这里的参数`handlers`非常重要，值得我们更加深入的研究。它应该是一个元组组成的列表，其中每个元组的第一个元素是一个用于匹配的正则表达式，第二个元素是一个`RequestHandler`类。在**hello.py**中，我们只指定了一个正则表达式`RequestHandler`对，但你可以按你的需要指定任意多个。

### 使用正则表达式指定路径

Tornado在元组中使用正则表达式来匹配HTTP请求的路径。（这个路径是URL中主机名后面的部分，不包括查询字符串和碎片。）Tornado把这些正则表达式看作已经包含了行开始和结束锚点（即，字符串`/`被看作为`^/$`）。

如果一个正则表达式包含一个捕获分组（即，正则表达式中的部分被括号括起来），匹配的内容将作为相应HTTP请求的参数传到RequestHandler对象中。我们将在下个例子中看到它的用法。
